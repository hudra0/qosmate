#!/bin/sh /etc/rc.common
# shellcheck disable=SC2034,SC3043,SC1091,SC2155,SC3020,SC3010,SC2016

source /etc/init.d/functions-qosmate/auto_setup
source /etc/init.d/functions-qosmate/auto_setup_noninteractive
source /etc/init.d/functions-qosmate/check_packages
source /etc/init.d/functions-qosmate/downloads-scripts
source /etc/init.d/functions-qosmate/expand_config
source /etc/init.d/functions-qosmate/install_packages
source /etc/init.d/functions-qosmate/migre_config
source /etc/init.d/functions-qosmate/migre_config
source /etc/init.d/functions-qosmate/validate_custom_rules

START=99
STOP=99

USE_PROCD=1

EXTRA_COMMANDS="check_version update auto_setup expand_config auto_setup_noninteractive validate_custom_rules"
EXTRA_HELP="        check_version   Check for updates
        update          Update qosmate
        auto_setup      Automatically configure qosmate
        expand_config   Expand the configuration with all possible options
        auto_setup_noninteractive   Automatically configure qosmate with no interaction
        validate_custom_rules    Validate custom rules"


# Base URL (raw) for repositories (can be overridden for different branches/commits)
QOSMATE_BASE_URL="${QOSMATE_BASE_URL:-https://raw.githubusercontent.com/hudra0/qosmate/main}"
QOSMATE_FRONTEND_BASE_URL="${QOSMATE_FRONTEND_BASE_URL:-https://raw.githubusercontent.com/hudra0/luci-app-qosmate/main}"
PACKAGE_MANAGER=""

load_config() {
    config_load 'qosmate'
    config_get WAN settings 'WAN' 'eth1'
}

create_hotplug_script() {
    mv /etc/init.d/file-qosmate/13-qosmateHotplug /etc/hotplug.d/iface/13-qosmateHotplug 
}

manage_custom_rules_file() {
    local action="$1"
    
    case "$action" in
        create)
            # Ensure the directory exists
            [ ! -d "/etc/qosmate.d" ] && mkdir -p "/etc/qosmate.d"
            
            # Create the file if it doesn't exist
            [ ! -f "/etc/qosmate.d/custom_rules.nft" ] && touch "/etc/qosmate.d/custom_rules.nft"

            ;;
        delete)
            # Not used at the moment...
            rm -f "/etc/qosmate.d/custom_rules.nft"
            ;;
    esac
}

start_service() {
    install_packages
    download_scripts
    create_hotplug_script  # Create the hotplug script instead of downloading it
    check_and_download_config || return 1
    migrate_config

    # Enable the global option
    uci set qosmate.global.enabled='1'
    uci commit qosmate

    # Save the current WAN interface to a temporary file
    load_config
    echo "$WAN" > /tmp/qosmate_wan

    # Create custom rules file if it doesn't exist
    manage_custom_rules_file create
    nft -f /etc/qosmate.d/custom_rules.nft

    /etc/qosmate.sh
    /etc/init.d/firewall reload
    logger -t qosmate "Service started"
    /etc/init.d/qosmate enable
}

stop_service() {
    # Read the old WAN interface from the temporary file
    OLD_WAN=$(cat /tmp/qosmate_wan 2>/dev/null)
    if [ -z "$OLD_WAN" ]; then
        # If the temporary file doesn't exist, fall back to WAN from config
        load_config
        OLD_WAN="$WAN"
    fi

    echo "Stopping service qosmate..."
    
    # Only disable if not in restart
    if [ "$DISABLE_ON_STOP" != "0" ]; then
        /etc/init.d/qosmate disable
        uci set qosmate.global.enabled='0'
        uci commit qosmate
    fi

    # Remove custom rules table
    nft delete table inet qosmate_custom 2>/dev/null

    ## Delete files
    rm -f /etc/hotplug.d/iface/13-qosmateHotplug
    rm -f /usr/share/nftables.d/ruleset-post/dscptag.nft

    ## Delete the old qdiscs and IFB associated with the old WAN interface
    tc qdisc del dev "$OLD_WAN" root > /dev/null 2>&1
    tc qdisc del dev ifb-"$OLD_WAN" root > /dev/null 2>&1
    tc qdisc del dev "$OLD_WAN" ingress > /dev/null 2>&1

    # Remove IFB interface
    ip link del ifb-"$OLD_WAN" 2>/dev/null

    nft delete table inet dscptag

    # Remove the temporary file
    rm -f /tmp/qosmate_wan

    echo "Reloading network service..."
    /etc/init.d/network reload
    /etc/init.d/firewall reload
    logger -t qosmate "Service stopped"
    exit 0
}

status_service() {
    # Load configuration
    config_load 'qosmate'

    # Function to extract default values from the main script
    get_default_value() {
        local var_name="$1"
        grep "^$var_name=" /etc/qosmate.sh | cut -d'=' -f2- | tr -d '"'
    }

    # Get current values, replace with defaults if not set
    local WAN UPRATE DOWNRATE GAMEUP GAMEDOWN gameqdisc
    config_get WAN settings WAN
    : "${WAN:="$(get_default_value DEFAULT_WAN)"}"
    config_get UPRATE settings UPRATE
    : "${UPRATE:="$(get_default_value DEFAULT_UPRATE)"}"
    config_get DOWNRATE settings DOWNRATE
    : "${DOWNRATE:="$(get_default_value DEFAULT_DOWNRATE)"}"

    config_get ROOT_QDISC settings ROOT_QDISC "hfsc"
    config_get gameqdisc hfsc gameqdisc
    : "${gameqdisc:="$(get_default_value DEFAULT_GAMEQDISC)"}"

    # For default GAMEUP and GAMEDOWN, we need to evaluate the expressions
    config_get GAMEUP hfsc GAMEUP
    : "${GAMEUP:=$((UPRATE*15/100+400))}"
    config_get GAMEDOWN hfsc GAMEDOWN
    : "${GAMEDOWN:=$((DOWNRATE*15/100+400))}"

    echo "==== qosmate Status ===="
    
    # Check if the service is enabled
    if /etc/init.d/qosmate enabled; then
        echo "qosmate service is enabled."
    else
        echo "qosmate service is not enabled."
    fi

    # Check if traffic shaping is active
    local IFB="ifb-$WAN"
    
    if tc qdisc show dev "$WAN" 2>/dev/null | grep -q "qdisc cake"; then
        if /etc/init.d/qosmate enabled; then
            echo "Traffic shaping is active on the egress interface ($WAN)."
        else
            echo "Default CAKE qdisc is active on the egress interface ($WAN), but qosmate is not managing it."
        fi
    elif tc qdisc show dev "$WAN" 2>/dev/null | grep -q "qdisc hfsc"; then
        echo "Traffic shaping (HFSC) is active on the egress interface ($WAN)."
    else
        echo "No qosmate traffic shaping is active on the egress interface ($WAN)."
    fi

    if tc qdisc show dev "$IFB" 2>/dev/null | grep -q "qdisc cake\|qdisc hfsc"; then
        echo "Traffic shaping is active on the ingress interface ($IFB)."
    else
        echo "Traffic shaping is not active on the ingress interface ($IFB)."
    fi

    echo "==== Overall Status ===="
    # Determine if the service is actually running
    if /etc/init.d/qosmate enabled && { tc qdisc show dev "$WAN" 2>/dev/null | grep -q "qdisc hfsc" ||
		tc qdisc show dev "$IFB" 2>/dev/null | grep -q "qdisc cake\|qdisc hfsc"; }; then
        	echo "qosmate is currently active and managing traffic shaping."
    else
        echo "qosmate is not currently active or managing traffic shaping."
    fi

    echo "==== Current Settings ===="
    # Show summary of current settings
    echo "Upload rate: $UPRATE kbps"
    echo "Download rate: $DOWNRATE kbps"
    
    echo "Game traffic upload: $GAMEUP kbps"
    echo "Game traffic download: $GAMEDOWN kbps"
    if [ "$ROOT_QDISC" = "cake" ]; then
        echo "Queue discipline: CAKE (Root qdisc)"
    else
        echo "Queue discipline: $gameqdisc (for game traffic in HFSC)"
    fi

    echo "==== Package Status ===="

    if check_pkg_manager "$pkg_manager" && check_package_status; then
        echo "All required packages are installed."
    else
        echo "Some required packages are missing. QoSmate may not function correctly."
    fi

    echo
    echo "==== Detailed Technical Information ===="
    echo "Traffic Control (tc) Queues:"
    tc -s qdisc

    echo
    echo "==== Nftables Ruleset (dscptag) ===="
    nft list ruleset | grep 'chain dscptag' -A 100


    echo
    echo "==== Custom Rules Table Status ===="
    if nft list table inet qosmate_custom &>/dev/null; then
        echo "Custom rules table (qosmate_custom) is active."
        echo "Current custom rules:"
        nft list table inet qosmate_custom
    else
        echo "Custom rules table (qosmate_custom) is not active or doesn't exist."
    fi

}

restart() {
    DISABLE_ON_STOP=0 /etc/init.d/qosmate stop
    sleep 1 # Ensure all processes have been properly terminated
    /etc/init.d/qosmate start    
}

reload_service() {
    restart
}

check_version() {
    local current_backend_version="$(grep '^VERSION=' /etc/qosmate.sh | cut -d'"' -f2)"
    local latest_backend_version="$(wget -qO- "$QOSMATE_BASE_URL/etc/qosmate.sh" | grep '^VERSION=' | cut -d'"' -f2)"
    
    local current_frontend_version="$(grep '^const UI_VERSION' /www/luci-static/resources/view/qosmate/settings.js | cut -d"'" -f2)"
    local latest_frontend_version="$(wget -qO- "$QOSMATE_FRONTEND_BASE_URL/htdocs/luci-static/resources/view/settings.js" | grep '^const UI_VERSION' | cut -d"'" -f2)"
    
    if [ -z "$latest_backend_version" ] || [ -z "$latest_frontend_version" ]; then
        echo "Error: Could not retrieve the latest versions."
        return 1
    fi
    
    echo "Backend versions:"
    echo "  Current version: $current_backend_version"
    echo "  Latest version:  $latest_backend_version"
    echo
    echo "Frontend versions:"
    echo "  Current version: $current_frontend_version"
    echo "  Latest version:  $latest_frontend_version"
    
    if [ "$current_backend_version" != "$latest_backend_version" ] || [ "$current_frontend_version" != "$latest_frontend_version" ]; then
        echo
        echo "A new version of QoSmate is available."
        echo "To update, run: /etc/init.d/qosmate update"
    else
        echo
        echo "QoSmate is up to date."
    fi
}
